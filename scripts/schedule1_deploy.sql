!set variable_substitution=true;
use database &{db_name};
create schema if not exists &{sc_name};
alter schema if exists &{sc_name}
set comment = 'This is used to manage the manual entry data';
use schema &{sc_name};
--
-- Add a control column on SELLSIDE_CONTRACTS table as a prerequirement
--
-- ALTER TABLE COMMON.SELLSIDE_CONTRACTS ADD COLUMN MANUAL_ENTRY_SCHEDULE_ALLOWED BOOLEAN DEFAULT FALSE;
-- UPDATE COMMON.SELLSIDE_CONTRACTS SET MANUAL_ENTRY_SCHEDULE_ALLOWED = TRUE WHERE CONTRACT_ID IN (12, 17, 18);
--
----------------------------------------
-- create the data structure
----------------------------------------
-- SHOW SEQUENCES LIKE 'SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION_SEQ%';
-- DROP SEQUENCE SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION_SEQ;
CREATE SEQUENCE SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION_SEQ START = 1 INCREMENT = 1;
ALTER SEQUENCE IF EXISTS SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION_SEQ
SET COMMENT = 'Used to generate the default identity value for "SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION"'
;
--
-- SHOW TABLES LIKE 'SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION%';
-- DROP TABLE SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION;
CREATE TABLE SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION (
	ID INTEGER DEFAULT SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION_SEQ.NEXTVAL
	,SELLSIDE_CONTRACT_ID NUMBER
	,REVENUE_MONTH DATE
	,MONTHLY_REVENUE_FORECAST FLOAT
	,MONTHLY_REVENUE_ACTUAL FLOAT
	,DATES_IN_MONTH VARIANT
	)
COMMENT = 'This table is used to store and manage the manual entry of the revenue data'
;
-- SHOW VIEWS LIKE 'SELLSIDE_DAILY_MANUAL_ENTRY%';
-- DROP VIEW SELLSIDE_DAILY_MANUAL_ENTRY;
CREATE VIEW SELLSIDE_DAILY_MANUAL_ENTRY
AS
SELECT DATEADD(DAY, F.VALUE - 1, DATE_TRUNC('MONTH', C.REVENUE_MONTH)) DATA_TS
	,DEFAULT_PRODUCT_LINE_ID PRODUCT_LINE_ID
	,P.NETWORK_ID
	,P.ACCOUNT_ID_LOOKUP_VALUE ACCOUNT_ID
	,C.SELLSIDE_CONTRACT_ID
	,M.CURRENCY_CODE
	,C.MONTHLY_REVENUE_FORECAST / DATE_PART(DAY, LAST_DAY(C.REVENUE_MONTH)) AVERAGE_DAILY_FORECAST
	,C.MONTHLY_REVENUE_ACTUAL / NULLIF(ARRAY_SIZE(DATES_IN_MONTH), 0) AVERAGE_DAILY_REVENUE
	,NULL::INT BIDDED_SEARCHES
	,NULL::INT CLICKS
	,COALESCE(
		C.MONTHLY_REVENUE_ACTUAL / NULLIF(ARRAY_SIZE(DATES_IN_MONTH), 0),
		C.MONTHLY_REVENUE_FORECAST / DATE_PART(DAY, LAST_DAY(C.REVENUE_MONTH))
		) ESTIMATED_REVENUE
FROM SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION C
JOIN BI.COMMON.SELLSIDE_CONTRACTS P
ON C.SELLSIDE_CONTRACT_ID = P.CONTRACT_ID
LEFT JOIN BI.COMMON.ACCOUNT_METADATA_MAPPINGS M
ON P.BI_ACCOUNT_ID = M.BI_ACCOUNT_ID
,LATERAL FLATTEN (INPUT => C.DATES_IN_MONTH) F
;
ALTER VIEW SELLSIDE_DAILY_MANUAL_ENTRY
SET COMMENT = 'This table is used to exposure the manual entry of the revenue data'
;
--
----------------------------------------
-- Partner contract monthly forecast setup
----------------------------------------
--INSERT INTO SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION (
--    SELLSIDE_CONTRACT_ID,
--    REVENUE_MONTH,
--    MONTHLY_REVENUE_FORECAST,
--    DATES_IN_MONTH
--)
--SELECT $1, $2, $3, PARSE_JSON($4)
--FROM VALUES (
--    16,             -- SELLSIDE_CONTRACT_ID
--    '2020-01-01',   -- REVENUE_MONTH
--    50000,          -- MONTHLY_REVENUE_FORECAST
--    '[12,13]'       -- DATES_IN_MONTH, preset the past dates
--);
--
----------------------------------------
-- Partner contract monthly renew proc
----------------------------------------
-- SHOW PROCEDURES LIKE 'SELLSIDE_CONTRACT_MANUAL_ENTRY_MONTHLY_RENEW%';
-- DROP PROCEDURE SELLSIDE_CONTRACT_MANUAL_ENTRY_MONTHLY_RENEW (VARCHAR);
--
CREATE PROCEDURE SELLSIDE_CONTRACT_MANUAL_ENTRY_MONTHLY_RENEW (
	REVENUE_MONTH VARCHAR
	)
RETURNS VARCHAR
LANGUAGE javascript
COMMENT = 'This SP is scheduled by a automated monthly task to renew the monthly contracts at the last minute of current month
    (1) The renewal result is controlled by both "IS_ENABALED" and "MANUAL_ENTRY_SCHEDULE_ALLOWED" of the SELLSIDE_CONTRACTS table
    (2) Those single-day-entry with the "MONTHLY_REVENUE_FORECAST" as a NULL will not be renewed.'
AS
$$
try {
var queryText = '';
var sqlScript = `
MERGE INTO SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION D
USING (
	SELECT C.SELLSIDE_CONTRACT_ID
		,DATE_TRUNC('MONTH', TO_DATE(:1)) REVENUE_MONTH
		,C.MONTHLY_REVENUE_FORECAST
		,NULL MONTHLY_REVENUE_ACTUAL
		,ARRAY_CONSTRUCT() DATES_IN_MONTH
	FROM SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION C
	JOIN (
		SELECT a.SELLSIDE_CONTRACT_ID
			,MAX(a.REVENUE_MONTH) REVENUE_MONTH
		FROM SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION a
		JOIN BI.COMMON.SELLSIDE_CONTRACTS b
			ON a.SELLSIDE_CONTRACT_ID = b.CONTRACT_ID
			AND b.MANUAL_ENTRY_SCHEDULE_ALLOWED
			AND b.IS_ENABLED
		WHERE MONTHLY_REVENUE_FORECAST IS NOT NULL
		GROUP BY 1
		) F
	ON C.SELLSIDE_CONTRACT_ID = F.SELLSIDE_CONTRACT_ID
	AND C.REVENUE_MONTH = F.REVENUE_MONTH
	) S
ON D.SELLSIDE_CONTRACT_ID = S.SELLSIDE_CONTRACT_ID
	AND D.REVENUE_MONTH = S.REVENUE_MONTH
WHEN MATCHED THEN
	UPDATE SET
		MONTHLY_REVENUE_FORECAST = S.MONTHLY_REVENUE_FORECAST
		,ID = D.ID
WHEN NOT MATCHED THEN
	INSERT (
		SELLSIDE_CONTRACT_ID
		,REVENUE_MONTH
		,MONTHLY_REVENUE_FORECAST
		,MONTHLY_REVENUE_ACTUAL
		,DATES_IN_MONTH
		)
	VALUES (
		S.SELLSIDE_CONTRACT_ID
		,S.REVENUE_MONTH
		,S.MONTHLY_REVENUE_FORECAST
		,S.MONTHLY_REVENUE_ACTUAL
		,S.DATES_IN_MONTH
		);
`;

var sqlStmt = snowflake.createStatement({
    sqlText: sqlScript,
    binds: [REVENUE_MONTH]
    });

var result = sqlStmt.execute();

queryText = sqlStmt.getSqlText()
    .replace(/:1/g, "'" + REVENUE_MONTH + "'");

return queryText;

} catch(err) {

return err;

}
$$;
--
----------------------------------------
-- Partner contract monthly closing proc
----------------------------------------
-- SHOW PROCEDURES LIKE 'SELLSIDE_CONTRACT_MANUAL_ENTRY_MONTHLY_UPDATE%';
-- DROP PROCEDURE SELLSIDE_CONTRACT_MANUAL_ENTRY_MONTHLY_UPDATE(VARCHAR, FLOAT, FLOAT, FLOAT);
--
CREATE PROCEDURE SELLSIDE_CONTRACT_MANUAL_ENTRY_MONTHLY_UPDATE (
	REVENUE_MONTH VARCHAR
	,SELLSIDE_CONTRACT_ID FLOAT
	,MONTHLY_REVENUE_FORECAST FLOAT
	,MONTHLY_REVENUE_ACTUAL FLOAT
	)
RETURNS VARCHAR
LANGUAGE javascript
COMMENT = 'This SP is manually executed by a person to fill the acutal bill or modify the contract budget setting
    (1) If MONTHLY_REVENUE_FORECAST argument is presented as a minus value, it will keep the existing budget value no change
    (2) If MONTHLY_REVENUE_ACTUAL argument is presented as -1 or NULL, it will reset the existing MONTHLY_REVENUE_ACTUAL to NULL'
AS
$$
try {
var queryText = '';
var sqlScript = `
UPDATE SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION
SET MONTHLY_REVENUE_FORECAST = CASE WHEN :3 >= 0 THEN :3 ELSE MONTHLY_REVENUE_FORECAST END
    ,MONTHLY_REVENUE_ACTUAL = NULLIF(:4, -1)
    ,ID = ID
WHERE REVENUE_MONTH = DATE_TRUNC('MONTH', TO_DATE(:1))
AND SELLSIDE_CONTRACT_ID = :2
`;

var sqlStmt = snowflake.createStatement({
    sqlText: sqlScript,
    binds: [REVENUE_MONTH, SELLSIDE_CONTRACT_ID, MONTHLY_REVENUE_FORECAST, MONTHLY_REVENUE_ACTUAL]
    });

var result = sqlStmt.execute();

queryText = sqlStmt.getSqlText()
    .replace(/:1/g, "'" + REVENUE_MONTH + "'")
    .replace(/:2/g, SELLSIDE_CONTRACT_ID)
    .replace(/:3/g, MONTHLY_REVENUE_FORECAST)
    .replace(/:4/g, MONTHLY_REVENUE_ACTUAL);

return queryText;

} catch(err) {

return err;

}
$$;
--
----------------------------------------
-- Partner contract single day billing proc
----------------------------------------
-- SHOW PROCEDURES LIKE 'SELLSIDE_CONTRACT_MANUAL_ENTRY_SINGLE_DAY_INSERT%';
-- CALL SELLSIDE_CONTRACT_MANUAL_ENTRY_SINGLE_DAY_INSERT ('2020-01-01',17,100.00);
-- DROP PROCEDURE SELLSIDE_CONTRACT_MANUAL_ENTRY_SINGLE_DAY_INSERT(VARCHAR, FLOAT, FLOAT);
--
CREATE PROCEDURE SELLSIDE_CONTRACT_MANUAL_ENTRY_SINGLE_DAY_INSERT (
	REVENUE_DATE VARCHAR
	,SELLSIDE_CONTRACT_ID FLOAT
	,MONTHLY_REVENUE_ACTUAL FLOAT
	)
RETURNS VARCHAR
LANGUAGE javascript
COMMENT = 'This SP is manually executed by a person to add a single-day manual entry
    (1) The result is controlled by the "MANUAL_ENTRY_SCHEDULE_ALLOWED" of the SELLSIDE_CONTRACTS
    (2) The single-day manual entry will maintain the MONTHLY_REVENUE_FORECAST as NULL internally to distinct from the automated manual entries
    (3) If MONTHLY_REVENUE_ACTUAL argument is presented as -1 or NULL, it will remove a single-day manual entry from table'
AS
$$
try {
var queryText = '';
var sqlScript = `
MERGE INTO SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION D
USING (
    SELECT CONTRACT_ID SELLSIDE_CONTRACT_ID,
        DATE_TRUNC('MONTH', TO_DATE(:1)) REVENUE_MONTH,
        NULL::FLOAT MONTHLY_REVENUE_FORECAST,
        :3 MONTHLY_REVENUE_ACTUAL,
        ARRAY_CONSTRUCT(DATE_PART(DAY, TO_DATE(:1))) DATES_IN_MONTH
    FROM BI.COMMON.SELLSIDE_CONTRACTS
    WHERE CONTRACT_ID = :2
) S
ON D.SELLSIDE_CONTRACT_ID = S.SELLSIDE_CONTRACT_ID
	AND D.REVENUE_MONTH = S.REVENUE_MONTH
    AND D.DATES_IN_MONTH[0] = S.DATES_IN_MONTH[0]
    AND ARRAY_SIZE(D.DATES_IN_MONTH) = 1
    AND D.MONTHLY_REVENUE_FORECAST IS NULL
WHEN MATCHED AND :3 = -1 THEN
	DELETE
WHEN MATCHED AND :3 > 0 THEN
	UPDATE SET
		MONTHLY_REVENUE_ACTUAL = S.MONTHLY_REVENUE_ACTUAL
        ,DATES_IN_MONTH = S.DATES_IN_MONTH
		,ID = D.ID
WHEN NOT MATCHED THEN
	INSERT (
		SELLSIDE_CONTRACT_ID
		,REVENUE_MONTH
		,MONTHLY_REVENUE_FORECAST
		,MONTHLY_REVENUE_ACTUAL
		,DATES_IN_MONTH
		)
	VALUES (
		S.SELLSIDE_CONTRACT_ID
		,S.REVENUE_MONTH
		,S.MONTHLY_REVENUE_FORECAST
		,S.MONTHLY_REVENUE_ACTUAL
		,S.DATES_IN_MONTH
		);
`;

var sqlStmt = snowflake.createStatement({
    sqlText: sqlScript,
    binds: [REVENUE_DATE, SELLSIDE_CONTRACT_ID, MONTHLY_REVENUE_ACTUAL]
    });

var result = sqlStmt.execute();

queryText = sqlStmt.getSqlText()
    .replace(/:1/g, "'" + REVENUE_DATE + "'")
    .replace(/:2/g, SELLSIDE_CONTRACT_ID)
    .replace(/:3/g, MONTHLY_REVENUE_ACTUAL);

return queryText;

} catch(err) {

return err;

}
$$;

----------------------------------------
-- Partner contract daily fufill proc for all
----------------------------------------
-- SHOW PROCEDURES LIKE 'SELLSIDE_CONTRACT_MANUAL_ENTRY_DAILY_UPDATE%';
-- DROP PROCEDURE SELLSIDE_CONTRACT_MANUAL_ENTRY_DAILY_UPDATE(VARCHAR);
--
CREATE PROCEDURE SELLSIDE_CONTRACT_MANUAL_ENTRY_DAILY_UPDATE (REVENUE_DATE VARCHAR)
RETURNS VARCHAR
LANGUAGE javascript
COMMENT = 'This SP is scheduled by a daily automated task to add the daily indicators to all MANUAL_ENTRY_SCHEDULE_ALLOWED contracts
    (1) The renewal result is controlled by both "IS_ENABALED" and "MANUAL_ENTRY_SCHEDULE_ALLOWED" of the SELLSIDE_CONTRACTS
    (2) If the argument of REVENUE_DATE is not presented, it will use current date as the date value'
AS
$$
try {
var queryText = '';
var sqlScript = `
MERGE INTO SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION D
USING (
	SELECT C.SELLSIDE_CONTRACT_ID
		,C.REVENUE_MONTH
		,C.MONTHLY_REVENUE_FORECAST
		,C.MONTHLY_REVENUE_ACTUAL
		,ARRAY_AGG(DISTINCT F.VALUE) WITHIN GROUP (ORDER BY F.VALUE) DATES_IN_MONTH
	FROM (
		SELECT a.*, ARRAY_APPEND(a.DATES_IN_MONTH, DATE_PART(DAY, TO_DATE(:1))) TEMP_DATES
		FROM SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION a
		JOIN BI.COMMON.SELLSIDE_CONTRACTS b
            ON a.SELLSIDE_CONTRACT_ID = b.CONTRACT_ID
		WHERE a.REVENUE_MONTH = DATE_TRUNC('MONTH', COALESCE(TO_DATE(:1), CURRENT_DATE()))
			AND b.MANUAL_ENTRY_SCHEDULE_ALLOWED
			AND b.IS_ENABLED
		) C
		,LATERAL FLATTEN(INPUT => TEMP_DATES) F
	GROUP BY C.SELLSIDE_CONTRACT_ID
		,C.REVENUE_MONTH
		,C.MONTHLY_REVENUE_FORECAST
		,C.MONTHLY_REVENUE_ACTUAL
	) S
ON D.SELLSIDE_CONTRACT_ID = S.SELLSIDE_CONTRACT_ID
    AND D.REVENUE_MONTH = S.REVENUE_MONTH
WHEN MATCHED THEN
	UPDATE SET
		DATES_IN_MONTH = S.DATES_IN_MONTH
		,ID = D.ID
WHEN NOT MATCHED THEN
	INSERT (
		SELLSIDE_CONTRACT_ID
		,REVENUE_MONTH
		,MONTHLY_REVENUE_FORECAST
		,MONTHLY_REVENUE_ACTUAL
		,DATES_IN_MONTH
		)
	VALUES (
		S.SELLSIDE_CONTRACT_ID
		,S.REVENUE_MONTH
		,S.MONTHLY_REVENUE_FORECAST
		,S.MONTHLY_REVENUE_ACTUAL
		,S.DATES_IN_MONTH
		);
`;

var sqlStmt = snowflake.createStatement({
    sqlText: sqlScript,
    binds: [REVENUE_DATE]
    });

var result = sqlStmt.execute();

queryText = sqlStmt.getSqlText()
    .replace(/:1/g, "'" + REVENUE_DATE + "'");

return queryText;

} catch(err) {

return err;

}
$$;

----------------------------------------
-- Partner contract daily fufill proc for individual
----------------------------------------
-- SHOW PROCEDURES LIKE 'SELLSIDE_CONTRACT_MANUAL_ENTRY_DAILY_UPDATE%';
-- CALL SELLSIDE_CONTRACT_MANUAL_ENTRY_DAILY_UPDATE('2020-03-01', 17, True);
-- DROP PROCEDURE SELLSIDE_CONTRACT_MANUAL_ENTRY_DAILY_UPDATE(VARCHAR, FLOAT, BOOLEAN);
--
CREATE OR REPLACE PROCEDURE SELLSIDE_CONTRACT_MANUAL_ENTRY_DAILY_UPDATE (
	REVENUE_DATE VARCHAR
	,SELLSIDE_CONTRACT_ID FLOAT
	,DATE_WILL_BE_REMAINED BOOLEAN
)
RETURNS VARCHAR
LANGUAGE javascript
COMMENT = 'This SP is manually executed by a person to modify the date indicators of a contract
    (1) The result is controlled by the "MANUAL_ENTRY_SCHEDULE_ALLOWED"
    (2) The data must be an automated manual entry, that means the MONTHLY_REVENUE_FORECAST containing a not null value
    (3) If the argument DATE_WILL_BE_REMAINED is presented as "True" to set a date; if it is presented as "Flase", it will unset a date
	(4) In case of wrong removing a configuration row, so it does not allow unset the dates array to an empty one'
AS
$$
try { 
var queryText = '';
var sqlScript = `
MERGE INTO SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION D
USING (
	SELECT C.SELLSIDE_CONTRACT_ID
		,C.REVENUE_MONTH
		,C.MONTHLY_REVENUE_FORECAST
		,C.MONTHLY_REVENUE_ACTUAL
		,ARRAY_AGG(DISTINCT F.VALUE) WITHIN GROUP (ORDER BY F.VALUE) DATES_IN_MONTH
    FROM (
        SELECT a.*, ARRAY_APPEND(a.DATES_IN_MONTH, DATE_PART(DAY, TO_DATE(:1))) TEMP_DATES
        FROM SELLSIDE_CONTRACT_MANUAL_ENTRY_CONFIGURATION a
        JOIN BI.COMMON.SELLSIDE_CONTRACTS b
            ON a.SELLSIDE_CONTRACT_ID = b.CONTRACT_ID
        WHERE a.REVENUE_MONTH = DATE_TRUNC('MONTH', COALESCE(TO_DATE(:1), CURRENT_DATE()))
            AND a.SELLSIDE_CONTRACT_ID = :2
            AND a.MONTHLY_REVENUE_FORECAST IS NOT NULL
            AND b.MANUAL_ENTRY_SCHEDULE_ALLOWED
        ) C
        ,LATERAL FLATTEN(INPUT => TEMP_DATES) F
	WHERE F.VALUE <> DATE_PART(DAY, TO_DATE(:1)) OR (1 = :3)
	GROUP BY C.SELLSIDE_CONTRACT_ID
		,C.REVENUE_MONTH
		,C.MONTHLY_REVENUE_FORECAST
		,C.MONTHLY_REVENUE_ACTUAL
	//ORDER BY 2,1
	) S
ON D.SELLSIDE_CONTRACT_ID = S.SELLSIDE_CONTRACT_ID
    AND D.REVENUE_MONTH = S.REVENUE_MONTH
WHEN MATCHED THEN
	UPDATE SET
		DATES_IN_MONTH = S.DATES_IN_MONTH
		,ID = D.ID
WHEN NOT MATCHED THEN
	INSERT (
		SELLSIDE_CONTRACT_ID
		,REVENUE_MONTH
		,MONTHLY_REVENUE_FORECAST
		,MONTHLY_REVENUE_ACTUAL
		,DATES_IN_MONTH
		)
	VALUES (
		S.SELLSIDE_CONTRACT_ID
		,S.REVENUE_MONTH
		,S.MONTHLY_REVENUE_FORECAST
		,S.MONTHLY_REVENUE_ACTUAL
		,S.DATES_IN_MONTH
		);
`;

var sqlStmt = snowflake.createStatement({
    sqlText: sqlScript,
    binds: [REVENUE_DATE, SELLSIDE_CONTRACT_ID, DATE_WILL_BE_REMAINED]
    });

var result = sqlStmt.execute();

queryText = sqlStmt.getSqlText()
    .replace(/:1/g, "'" + REVENUE_DATE + "'")
    .replace(/:2/g, SELLSIDE_CONTRACT_ID)
    .replace(/:3/g, DATE_WILL_BE_REMAINED);

return queryText;

} catch(err) {

return err;

}
$$;
